<!DOCTYPE HTML>
<html class="no-js" lang="zh-CN">
<head>
    <!--[if lte IE 9]>
<meta http-equiv="refresh" content="0;url=https://juejin.im/user/5dfad50cf265da33d21e7e0d/posts/warn.html">
<![endif]-->
<meta charset="utf-8">
<meta http-equiv="X-DNS-Prefetch-Control" content="on">
<link rel="dns-prefetch" href="https://juejin.im/user/5dfad50cf265da33d21e7e0d/posts">
<link rel="dns-prefetch" href="//www.google-analytics.com">
<link rel="prefetch" href="https://juejin.im/user/5dfad50cf265da33d21e7e0d/posts">
<link rel="prefetch" href="//www.google-analytics.com">


<link rel="prerender" href="https://juejin.im/user/5dfad50cf265da33d21e7e0d/posts">

<meta http-equiv="X-UA-Compatible" content="IE=Edge">
<meta name="renderer" content="webkit">
<meta name="viewport" content="width=device-width, initial-scale=1.0,user-scalable=no">
<meta http-equiv="mobile-agent" content="format=html5; url=https://juejin.im/user/5dfad50cf265da33d21e7e0d/posts">
<meta name="author" content="">

<link rel="stylesheet" href="/css/JSimple.css">


<link rel="shortcut icon" href="/images/favicon.ico">


<title>【你应该掌握的】promise基础知识&amp;如何实现一个简单的promise - skFe</title>

<meta name="keywords" content="">

<meta name="description " content="promise">

    <script type="text/x-mathjax-config">
        MathJax.Hub.Config({
            tex2jax: {
                inlineMath: [ ['$','$'], ["\\(","\\)"] ],
                processEscapes: true
            }
        });
    </script>


    

    

<meta name="generator" content="Hexo 4.1.1"></head>
<body>
<div id="nav">
    <nav class="nav-menu">
        <a class="site-name current" href="/" title="说">说</a>
        <a class="site-index current" href="/"><i class="fa fa-home"></i><span>首页</span></a>
        <a href="/archives" title="归档"><i class="fa fa-archives"></i><span>归档</span></a>
        <a href="/tags" title="标签"><i class="fa fa-tags"></i><span>标签</span></a>
        <!-- custom single page of menus -->
        
        
        <a href="/help" title="帮助">
            <i class="fa "></i>
            <span>帮助</span>
        </a>
        
    </nav>
</div>

<div class="nav-user">
    <a class="btn-search" href="#"><i class="fa fa-search"></i></a>
    <a class="btn-read-mode" href="#"><i class="fa fa-sun-o"></i></a>
    <a class="btn-sns-qr" href="javascript:"><i class="fa fa-telegram"></i></a>
</div>

<div id="wrapper" class="clearfix">
    <div id="body">
        <div class="main" id="main">
            <div id="cover">
    <div class="cover-img"></div>
    <div class="cover-info">
        
        <h1 class="cover-siteName">skFe</h1>
        <h3 class="cover-siteTitle">无忧亦无惧</h3>
        <p class="cover-siteDesc">从0到1，从1到n。</p>
        <div class="cover-sns">
            
    &nbsp;&nbsp;<div class="btn btn-github">
        <a href="https://github.com/skfeteam/skfeteam.github.io" target="_blank" title="github" ref="friend">
            <i class="fa fa-github"></i>
        </a>
    </div>


        </div>
    </div>
</div>

            <div class="page-title">
    <ul>
        <li><a href="/">文章</a></li>
        
        
        
        <li class="page-search">
    <form id="search" class="search-form">
        <input type="text"
               readonly="readonly"
               id="local-search-input-tip"
               placeholder="读物检索~" />
        <button type="button" disabled="disabled" class="search-form-submit"><i class="fa fa-search"></i></button>
    </form>
</li>

    </ul>
</div>
<div class="main-inner">
    <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
        <div class="post-header">
            <div class="post-author clearfix">
                <a class="avatar fleft" href="https://juejin.im/user/5dfad50cf265da33d21e7e0d/posts"
                   target="_blank">
                    <img width="48" src="/images/favicon.png" alt="avatar"/>
                </a>
                <p><span class="label">站点所有</span>
                    <a href="https://juejin.im/user/5dfad50cf265da33d21e7e0d/posts"
                       target="_blank">高扬</a>
                    <span title="最后编辑于&nbsp;2020-01-10">2020-01-10</span>
                </p>
                <p>skFe</p>
            </div>
            <h2 class="post-title">【你应该掌握的】Promise基础知识&如何实现一个简单的Promise</h2>
            <div class="post-meta">
                本文共计17977个字 |
                您是第&nbsp;<span id="busuanzi_value_page_pv"><i class="fa fa-spinner fa-spin"></i></span>位看到它们的小伙伴
            </div>
        </div>
        <div class="post-content markdown-body">
            <h3 id="Promise是前端基础技能中较为重要的一部分，本文将从以下几个方面展开Promise的相关知识，与大家交流。"><a href="#Promise是前端基础技能中较为重要的一部分，本文将从以下几个方面展开Promise的相关知识，与大家交流。" class="headerlink" title="Promise是前端基础技能中较为重要的一部分，本文将从以下几个方面展开Promise的相关知识，与大家交流。"></a>Promise是前端基础技能中较为重要的一部分，本文将从以下几个方面展开Promise的相关知识，与大家交流。</h3><ul>
<li>什么是Promise</li>
<li>Promise可以解决什么问题</li>
<li>该类问题是否有其他解决方案</li>
<li>如何使用Promise</li>
<li>如何自己实现Promise</li>
</ul>
<h3 id="什么是Promise"><a href="#什么是Promise" class="headerlink" title="什么是Promise?"></a>什么是Promise?</h3><p>Promise是一种异步编程的解决方案，已经被纳入ES6规范当中。在Promise出现之前，传统的异步编程方案主要是<strong>点击事件</strong>以及<strong>回调函数</strong>。</p>
<h3 id="Promise可以解决什么问题？"><a href="#Promise可以解决什么问题？" class="headerlink" title="Promise可以解决什么问题？"></a>Promise可以解决什么问题？</h3><p>简单来说，Promise可以避免出现<strong>回调地狱</strong>。</p>
<h4 id="什么是回调地狱？"><a href="#什么是回调地狱？" class="headerlink" title="什么是回调地狱？"></a>什么是回调地狱？</h4><p>JQuery中发起一个异步请求可以写为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">    type: &#39;GET&#39;,</span><br><span class="line">    url: &#39;xxx&#39;,</span><br><span class="line">    ...,</span><br><span class="line">    success:function (data) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>如果业务需要扩展，在获取到请求结果后再发起一个异步请求，则代码扩展为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">    type: &#39;GET&#39;,</span><br><span class="line">    url: &#39;xxx&#39;,</span><br><span class="line">    ...,</span><br><span class="line">    success:function (data1) &#123;</span><br><span class="line">        &#x2F;&#x2F; 另一个异步请求</span><br><span class="line">        $.ajax(&#123;</span><br><span class="line">            url: &#39;xxx&#39;,</span><br><span class="line">            success: function (data2) &#123;</span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>如果业务更加复杂，需要依次执行多个异步任务，那么这些异步任务就会一层一层嵌套在上一个异步任务成功的回调函数中，我们称之为<strong>回调地狱</strong>，代码片段如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 第一个异步请求</span><br><span class="line">$.ajax(&#123;</span><br><span class="line">    url: &#39;x&#39;,</span><br><span class="line">    success:function (data1) &#123;</span><br><span class="line">        &#x2F;&#x2F; 第二个异步请求</span><br><span class="line">        $.ajax(&#123;</span><br><span class="line">            url: &#39;xx&#39;,</span><br><span class="line">            success: function (data2) &#123;</span><br><span class="line">                &#x2F;&#x2F; 第三个异步请求</span><br><span class="line">                $.ajax(&#123;</span><br><span class="line">                    url:&#39;xxx&#39;,</span><br><span class="line">                    success: function (data3) &#123;</span><br><span class="line">                        &#x2F;&#x2F; 第四个异步请求</span><br><span class="line">                        $.ajax(&#123;</span><br><span class="line">                            url: &#39;xxxx&#39;,</span><br><span class="line">                            success: function (data4) &#123;</span><br><span class="line">                                &#x2F;&#x2F; 第五个异步请求</span><br><span class="line">                                $.ajax(&#123;</span><br><span class="line">                                    url: &#39;xxxxx&#39;,</span><br><span class="line">                                    success: function (data5) &#123;</span><br><span class="line">                                        &#x2F;&#x2F; 第N个回调函数</span><br><span class="line">                                        ...</span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125;)</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="回调地狱会造成哪些问题？"><a href="#回调地狱会造成哪些问题？" class="headerlink" title="回调地狱会造成哪些问题？"></a>回调地狱会造成哪些问题？</h4><ul>
<li>代码可读性差</li>
<li>业务耦合度高，可维护性差</li>
<li>代码臃肿</li>
<li>代码可复用性低</li>
<li>排查问题困难  </li>
</ul>
<p>因为Promise可以避免回调地狱的出现，因此以上问题也是Promise可以解决的问题。  </p>
<h3 id="该问题还有其他解决方案吗？"><a href="#该问题还有其他解决方案吗？" class="headerlink" title="该问题还有其他解决方案吗？"></a>该问题还有其他解决方案吗？</h3><p>Promise规范推出后，基于该规范产生了许多回调地狱的解决方案，包括ES6原生Promise，bluebird，Q，then.js等。</p>
<p>此处可参考知乎<a href="https://www.zhihu.com/question/25413141/answer/30767780" target="_blank" rel="noopener">nodejs异步控制「co、async、Q 、『es6原生promise』、then.js、bluebird」有何优缺点？最爱哪个？哪个简单？</a> 不再赘述。</p>
<h3 id="Promise如何使用？"><a href="#Promise如何使用？" class="headerlink" title="Promise如何使用？"></a>Promise如何使用？</h3><h4 id="构造函数及API"><a href="#构造函数及API" class="headerlink" title="构造函数及API"></a>构造函数及API</h4><p>一个完整的Promise对象包括以下几个部分：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">new Promise(function(resolve,reject) &#123;</span><br><span class="line">    ...</span><br><span class="line">    resolve(&#39;success_result&#39;);</span><br><span class="line">&#125;).then(function (resolve) &#123;</span><br><span class="line">    console.log(resolve); &#x2F;&#x2F; success_result</span><br><span class="line">&#125;).catch(function (reject) &#123;</span><br><span class="line">    console.log(reject);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>对象声明主体</strong>：方法主体，发起异步请求，返回的<strong>成功</strong>结果用<strong>resolve</strong>包裹，返回的<strong>失败</strong>结果用<strong>reject</strong>包裹。<br><strong>then</strong>：异步请求成功的回调函数，可以接收一个参数，即异步请求成功的返回结果，或不接收参数。<br><strong>catch</strong>：异步请求失败的回调函数，处理捕获的异常或异步请求失败的后续逻辑，至多接收一个参数，即失败的返回结果。  </p>
<p>每个Promise对象包含三种状态：</p>
<ul>
<li>pending:初始状态</li>
<li>fulfilled/resolved:操作成功</li>
<li>rejected:操作失败  </li>
</ul>
<p>Promise对象的状态无法由外界改变，且当状态变化为fulfilled/resolved或者rejected时，不会再发生变更。  </p>
<p>我们也可以构造一个特定状态的Promise对象，如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let fail &#x3D; Promise.reject(&#39;fail&#39;);</span><br><span class="line"></span><br><span class="line">let success &#x3D; Promise.resolve(23);</span><br></pre></td></tr></table></figure>

<p>不常用API之<strong>Promise.all()</strong><br>将多个Promise对象包装成一个Promise，如果全部执行成功，则返回所有成功结果的数组，如果有任务执行失败，则返回最先失败的Promise对象的返回结果。<br>示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">let p1 &#x3D; new Promise(function (resolve, reject) &#123;</span><br><span class="line">  resolve(&#39;成功&#39;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">let p2 &#x3D; new Promise(function (resolve, reject) &#123;</span><br><span class="line">  resolve(&#39;success&#39;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">let p3 &#x3D; Promse.reject(&#39;失败&#39;);</span><br><span class="line"></span><br><span class="line">Promise.all([p1, p2]).then(function (result) &#123;</span><br><span class="line">  console.log(result); &#x2F;&#x2F; [&#39;成功&#39;, &#39;success&#39;]</span><br><span class="line">&#125;).catch(function (error) &#123;</span><br><span class="line">  console.log(error);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">Promise.all([p1,p3,p2]).then(function (result) &#123;</span><br><span class="line">  console.log(result);</span><br><span class="line">&#125;).catch(function (error) &#123;</span><br><span class="line">  console.log(error);  &#x2F;&#x2F; &#39;失败&#39;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>不常用API之<strong>Promise.race()</strong><br>多个异步任务同时执行，返回最先执行结束的任务的结果，无论成功还是失败。<br>示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">let p1 &#x3D; new Promise(function (resolve, reject) &#123;</span><br><span class="line">  setTimeout(function () &#123;</span><br><span class="line">    resolve(&#39;success&#39;);</span><br><span class="line">  &#125;,1000);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">let p2 &#x3D; new Promise(function (resolve, reject) &#123;</span><br><span class="line">  setTimeout(function () &#123;</span><br><span class="line">    reject(&#39;failed&#39;);</span><br><span class="line">  &#125;, 500);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">Promise.race([p1, p2]).then(function (result) &#123;</span><br><span class="line">  console.log(result);</span><br><span class="line">&#125;).catch(function (error) &#123;</span><br><span class="line">  console.log(error);  &#x2F;&#x2F; &#39;failed&#39;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="Promise支持链式调用"><a href="#Promise支持链式调用" class="headerlink" title="Promise支持链式调用"></a>Promise支持链式调用</h4><p>Promise的then方法中允许追加新的Promise对象。<br>因此回调地狱可以改写为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">var p1 &#x3D; new Promise(function (resolve, reject) &#123;</span><br><span class="line">    ...</span><br><span class="line">    resolve(&#39;success1&#39;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">var p2 &#x3D; p1.then(function (resolve1) &#123;</span><br><span class="line">    ...</span><br><span class="line">    console.log(resolve1); &#x2F;&#x2F; success1</span><br><span class="line">    resolve(&#39;success2&#39;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">var p3 &#x3D; p2.then(function (resolve2) &#123;</span><br><span class="line">    console.log(resolve2); &#x2F;&#x2F; success2</span><br><span class="line">    resolve(&#39;success3&#39;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">var p4 &#x3D; p3.then(...);</span><br><span class="line"></span><br><span class="line">var p5 &#x3D; p4.then(...);</span><br></pre></td></tr></table></figure>

<p>也可以简写为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">new Promise(function (resolve, reject) &#123;</span><br><span class="line">    resolve(&#39;success1&#39;);</span><br><span class="line">&#125;).then(function (resolve1) &#123;</span><br><span class="line">    console.log(resolve1); &#x2F;&#x2F; success1</span><br><span class="line">    resolve(&#39;success2&#39;);</span><br><span class="line">&#125;).then(function (resolve2) &#123;</span><br><span class="line">    console.log(resolve2); &#x2F;&#x2F; success2</span><br><span class="line">    resolve(&#39;success3&#39;);</span><br><span class="line">&#125;).then(...);</span><br></pre></td></tr></table></figure>

<p>以上逻辑均表示当接收到上一个异步任务返回的“success${N}”结果之后，才会执行下一个异步任务。<br>链式调用的一个特殊情况是<strong>透传</strong>，Promise也是支持的，因为无论当前then方法有没有接收到参数，都会返回一个Promise，这样才可以支持链式调用，才会有下一个then方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">let p &#x3D; new Promise(function (resolve, reject) &#123;</span><br><span class="line">    resolve(1);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">p.then(data &#x3D;&gt; 2)</span><br><span class="line">.then()</span><br><span class="line">.then()</span><br><span class="line">.then(data &#x3D;&gt; &#123;</span><br><span class="line">    console.log(data); &#x2F;&#x2F;2</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="Promise在事件循环中的执行过程？"><a href="#Promise在事件循环中的执行过程？" class="headerlink" title="Promise在事件循环中的执行过程？"></a>Promise在事件循环中的执行过程？</h3><p>Promise在初始化时，代码是同步执行的，即前文提及的对象声明主体部分，而在then中注册的回调函数是一个微任务，会在浏览器清空微任务队列时执行。  </p>
<p>关于浏览器中的事件循环请参考<a href="https://juejin.im/post/5e01e0f76fb9a01622779fad">宏任务与微任务</a>。</p>
<h4 id="Promise升级之async-await的执行过程"><a href="#Promise升级之async-await的执行过程" class="headerlink" title="Promise升级之async/await的执行过程"></a>Promise升级之async/await的执行过程</h4><p>ES6中出现的async/await也是基于Promise实现的，因此在考虑async/await代码在事件循环中的执行时机时仍然参考Promise。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function func1() &#123;</span><br><span class="line">    return &#39;await&#39;;</span><br><span class="line">&#125;;</span><br><span class="line">let func2 &#x3D; async function () &#123;</span><br><span class="line">    let data2&#x3D; await func1();</span><br><span class="line">    console.log(&#39;data2:&#39;, data2);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>以上代码可以用Promise改写为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let func1 &#x3D; Promise.resolve(&#39;await&#39;);</span><br><span class="line"></span><br><span class="line">let func2 &#x3D; function (data) &#123;</span><br><span class="line">    func1.then(function (resolve) &#123;</span><br><span class="line">        let data2 &#x3D; resolve;</span><br><span class="line">        console.log(&#39;data2:&#39;, data2);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>从改写后的Promise可以看出 <strong>console.log(‘data2:’, data2)</strong> 在微任务队列里，因此改写前的 <strong>console.log(‘data2:’, data2)</strong> 也是在微任务队列中。 </p>
<p>由此可推断出下列代码片段中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function func1() &#123;</span><br><span class="line">    console.log(&#39;func1&#39;);</span><br><span class="line">&#125;;</span><br><span class="line">let func2 &#x3D; async function () &#123;</span><br><span class="line">    let data &#x3D; await func1();</span><br><span class="line">    console.log(&#39;func2&#39;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>console.log(‘func2’)</strong> 也是微任务。</p>
<h3 id="如何手写一个Promise？"><a href="#如何手写一个Promise？" class="headerlink" title="如何手写一个Promise？"></a>如何手写一个Promise？</h3><p>首先，Promise对象包含三种状态，pending，fulfilled/resolved，rejected，并且pending状态可修改为fulfilled/resolved或者rejected，此外我们还需要一个变量存储异步操作返回的结果，因此可以得到以下基本代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 定义Promise的三种状态</span><br><span class="line">const PENDING &#x3D; &#39;pending&#39;;</span><br><span class="line">const RESOLVED &#x3D; &#39;resolved&#39;;</span><br><span class="line">const REJECTED &#x3D; &#39;rejected&#39;;</span><br><span class="line"></span><br><span class="line">function Promise(executor) &#123;</span><br><span class="line">    this.state &#x3D; PENDING;</span><br><span class="line">    this.value &#x3D; undefined; &#x2F;&#x2F; 用于存储异步操作的返回结果</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 异步操作成功的回调函数</span><br><span class="line">     * @param &#123;*&#125; value 异步操作成功的返回结果</span><br><span class="line">     *&#x2F;</span><br><span class="line">    function resolve(value) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 异步操作失败的回调函数</span><br><span class="line">     * @param &#123;*&#125; value 异步操作失败的抛出错误</span><br><span class="line">     *&#x2F;</span><br><span class="line">    function reject(value) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module.exports &#x3D; Promise;</span><br></pre></td></tr></table></figure>

<p>为了增强代码的可读性我们把三种状态定义为常量。</p>
<p>每一个Promise对象都需要提供一个then方法用于处理异步操作的返回值。我们将它定义在原型上。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Promise.prototype.then &#x3D; function (onFulfilled, onRejected) &#123;</span><br><span class="line">    console.log(&#39;then&#39;); &#x2F;&#x2F; 测试语句</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>此时我们写一段代码来测试这个Promise</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let p &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&#39;p&#39;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">p.then(() &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&#39;p then&#39;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">then</span><br></pre></td></tr></table></figure>

<p>因为我们现在还没有对声明Promise对象以及then方法的入参做任何处理，因此<strong>p</strong>和<strong>p then</strong>都不会打印。<br>首先我们给Promise的声明中增加代码执行入参。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function Promise(executor) &#123;</span><br><span class="line">    this.state &#x3D; PENDING;</span><br><span class="line">    this.value &#x3D; undefined; &#x2F;&#x2F; 用于存储异步操作的返回结果</span><br><span class="line"></span><br><span class="line">    executor(resolve, reject); &#x2F;&#x2F; 立刻执行</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 异步操作成功的回调函数</span><br><span class="line">     * @param &#123;*&#125; value 异步操作成功的返回结果</span><br><span class="line">     *&#x2F;</span><br><span class="line">    function resolve(value) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 异步操作失败的回调函数</span><br><span class="line">     * @param &#123;*&#125; value 异步操作失败的抛出错误</span><br><span class="line">     *&#x2F;</span><br><span class="line">    function reject(value) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>此时测试代码输出为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p</span><br><span class="line">then</span><br></pre></td></tr></table></figure>

<p>接下来我们来完善resolve和reject方法。因为Promise状态只可以由pending变化为resolved或者rejected，且变化后就不可以再变更。因此代码可扩充为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">function Promise(executor) &#123;</span><br><span class="line">    var _this &#x3D; this;</span><br><span class="line">    this.state &#x3D; PENDING;</span><br><span class="line">    this.value &#x3D; undefined; &#x2F;&#x2F; 用于存储异步操作的返回结果 成功与失败共用一个变量，也可以选择分开</span><br><span class="line"></span><br><span class="line">    executor(resolve, reject); &#x2F;&#x2F; 立刻执行</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 异步操作成功的回调函数</span><br><span class="line">     * @param &#123;*&#125; value 异步操作成功的返回结果</span><br><span class="line">     *&#x2F;</span><br><span class="line">    function resolve(value) &#123;</span><br><span class="line">        if(_this.state &#x3D;&#x3D;&#x3D; PENDING) &#123;</span><br><span class="line">            _this.value &#x3D; value;</span><br><span class="line">            _this.state &#x3D; RESOLVED;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 异步操作失败的回调函数</span><br><span class="line">     * @param &#123;*&#125; value 异步操作失败的抛出错误</span><br><span class="line">     *&#x2F;</span><br><span class="line">    function reject(value) &#123;</span><br><span class="line">        if(_this.state &#x3D;&#x3D;&#x3D; PENDING) &#123;</span><br><span class="line">            _this.value &#x3D; value;</span><br><span class="line">            this.state &#x3D; REJECTED;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>接下来完善then方法，成功时调用注册的成功回调函数，失败时调用注册的失败回调函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Promise.prototype.then &#x3D; function (onFulfilled, onRejected) &#123;</span><br><span class="line">    if (this.state &#x3D;&#x3D;&#x3D; RESOLVED) &#123;</span><br><span class="line">        if (typeof onFulfilled &#x3D;&#x3D;&#x3D; &#39;function&#39;) &#123;</span><br><span class="line">            onFulfilled(this.value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (this.state &#x3D;&#x3D;&#x3D; REJECTED) &#123;</span><br><span class="line">        if (typeof onRejected &#x3D;&#x3D;&#x3D; &#39;function&#39;) &#123;</span><br><span class="line">            onRejected(this.value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>考虑到后续代码逻辑会复杂化，为了减少在各个条件下都去判断onFulfilled和onRejected是否是一个方法的重复代码，代码可再次优化为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Promise.prototype.then &#x3D; function (onFulfilled, onRejected) &#123;</span><br><span class="line"></span><br><span class="line">    onFulfilled &#x3D; typeof onFulfilled &#x3D;&#x3D;&#x3D; &#39;function&#39; ? onFulfilled : (onFulfilled) &#x3D;&gt; onFulfilled;</span><br><span class="line">    onRejected &#x3D; typeof onRejected &#x3D;&#x3D;&#x3D; &#39;function&#39; ? onRejected : (onRejected) &#x3D;&gt; &#123;</span><br><span class="line">        throw onRejected;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    if (this.state &#x3D;&#x3D;&#x3D; RESOLVED) &#123;</span><br><span class="line">        onFulfilled(this.value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (this.state &#x3D;&#x3D;&#x3D; REJECTED) &#123;</span><br><span class="line">        onRejected(this.value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>此时修改测试代码为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let p &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&#39;p&#39;);</span><br><span class="line">    resolve(&#39;success&#39;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">p.then((value) &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&#39;p then&#39;, value);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p</span><br><span class="line">then</span><br><span class="line">p then success</span><br></pre></td></tr></table></figure>

<p>但是此时我们手写的Promise还不支持异步操作，运行如下测试代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let p &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">    setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">        resolve(1);</span><br><span class="line">    &#125;, 500);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">p.then((value) &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&#39;p then&#39;, value);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>会发现<strong>p then 1</strong>并不会输出。这是因为setTimeout使得resolve延迟执行，所以当运行then方法时，state还没有变更为resolved，所以也不会调用onFulfilled方法。<br>为了解决这个问题，我们可以为成功的回调函数和失败的回调函数各建立一个数组，当执行到then方法时若对象状态还没有发生变化，就将回调函数寄存在数组中，等到状态发生改变后再取出执行。<br>首先，需要新增两个数组保存回调函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function Promise(executor) &#123;</span><br><span class="line">    var _this &#x3D; this;</span><br><span class="line">    this.state &#x3D; PENDING;</span><br><span class="line">    this.value &#x3D; undefined; &#x2F;&#x2F; 用于存储异步操作的返回结果 成功与失败共用一个变量，也可以选择分开</span><br><span class="line">    this.onFulfilledFunc &#x3D; []; &#x2F;&#x2F; 保存成功的回调函数</span><br><span class="line">    this.onRejectedFunc &#x3D; []; &#x2F;&#x2F; 保存失败的回调函数</span><br><span class="line"></span><br><span class="line">    executor(resolve, reject); &#x2F;&#x2F; 立刻执行</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>然后，我们在then方法中增加逻辑，若当前Promise对象还处于pending状态，将回调函数保存在对应数组中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Promise.prototype.then &#x3D; function (onFulfilled, onRejected) &#123;</span><br><span class="line">    ...</span><br><span class="line">    if (this.state &#x3D;&#x3D;&#x3D; PENDING) &#123;</span><br><span class="line">        this.onFulfilledFunc.push(onFulfilled);</span><br><span class="line">        this.onRejectedFunc.push(onRejected);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if (this.state &#x3D;&#x3D;&#x3D; RESOLVED) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (this.state &#x3D;&#x3D;&#x3D; REJECTED) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>保存好回调函数后，当状态改变，依次执行回调函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 异步操作成功的回调函数</span><br><span class="line"> * @param &#123;Function&#125; value 异步操作成功的返回结果</span><br><span class="line"> *&#x2F;</span><br><span class="line">function resolve(value) &#123;</span><br><span class="line">    if(_this.state &#x3D;&#x3D;&#x3D; PENDING) &#123;</span><br><span class="line">        _this.value &#x3D; value;</span><br><span class="line">        _this.onFulfilledFunc.forEach(fn &#x3D;&gt; fn(value));</span><br><span class="line">        _this.state &#x3D; RESOLVED;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 异步操作失败的回调函数</span><br><span class="line"> * @param &#123;Function&#125; value 异步操作失败的抛出错误</span><br><span class="line"> *&#x2F;</span><br><span class="line">function reject(value) &#123;</span><br><span class="line">    if(_this.state &#x3D;&#x3D;&#x3D; PENDING) &#123;</span><br><span class="line">        _this.value &#x3D; value;</span><br><span class="line">        _this.onRejectedFunc.forEach(fn &#x3D;&gt; fn(value));</span><br><span class="line">        this.state &#x3D; REJECTED;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时重新执行测试代码，输出了<strong>p then 1</strong>，至此，我们已经支持了Promise的异步执行。<br>接下来我们再运行一段代码来测试一下Promise的链式调用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">let p &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">    setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">        resolve(1);</span><br><span class="line">    &#125;, 500);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">p.then((value) &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&#39;p then&#39;, value);</span><br><span class="line">    resolve(2);</span><br><span class="line">&#125;).then((value) &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&#39;then then &#39;, value);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>会发现不仅没有输出正确的结果，控制台还有报错。<br>支持链式调用的核心在于，每一次调用都会返回一个Promise，这样才能支持下一个then方法的调用。<br>其次，为了支持Promise的链式调用，需要递归比较前后两个Promise并按不同情况处理，此时我们需要分几种情况去考虑：</p>
<ul>
<li>当前then方法resolve的就是一个Promise -&gt; 直接返回</li>
<li>当前then方法resolve的是一个常量 -&gt; 包装成Promise返回</li>
<li>当前then方法没有resolve -&gt; 视为undefined包装成Promise返回</li>
<li>当前then方法既没有入参也没有resolve -&gt; 继续向下传值，支持透传</li>
<li>当前then方法执行出现异常 -&gt; 调用reject方法并传递给下一个then的reject  </li>
</ul>
<p>接下来我们来改写then方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Promise.prototype.then &#x3D; function (onFulfilled, onRejected) &#123;</span><br><span class="line"></span><br><span class="line">    let self &#x3D; this;</span><br><span class="line">    let promise2; &#x2F;&#x2F; 用于保存最终需要return的promise对象</span><br><span class="line"></span><br><span class="line">    if (this.state &#x3D;&#x3D;&#x3D; RESOLVED) &#123;</span><br><span class="line">        promise2 &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (this.state &#x3D;&#x3D;&#x3D; REJECTED) &#123;</span><br><span class="line">        promise2 &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (this.state &#x3D;&#x3D;&#x3D; PENDING) &#123;</span><br><span class="line">        promise2 &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return promise2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>抽取出独立的递归函数处理then方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 根据上一个对象的then返回一个新的Promise</span><br><span class="line"> * @param &#123;*&#125; promise </span><br><span class="line"> * @param &#123;*&#125; x 上一个then的返回值</span><br><span class="line"> * @param &#123;*&#125; resolve 新的promise的resolve</span><br><span class="line"> * @param &#123;*&#125; reject 新的promise的reject</span><br><span class="line"> *&#x2F;</span><br><span class="line">function resolvePromise(promise, x, resolve, reject) &#123;</span><br><span class="line">    if (promise &#x3D;&#x3D;&#x3D; x &amp;&amp; x !&#x3D;&#x3D; undefined) &#123;</span><br><span class="line">        reject(new TypeError(&#39;发生了循环引用&#39;));</span><br><span class="line">    &#125;</span><br><span class="line">    if (x !&#x3D;&#x3D; null &amp;&amp; (typeof x &#x3D;&#x3D;&#x3D; &#39;function&#39; || typeof x &#x3D;&#x3D;&#x3D; &#39;object&#39;)) &#123;</span><br><span class="line">        &#x2F;&#x2F; 对象或函数</span><br><span class="line">        try &#123;</span><br><span class="line">            let then  &#x3D; x.then;</span><br><span class="line">            if (typeof then &#x3D;&#x3D;&#x3D; &#39;function&#39;) &#123;</span><br><span class="line">                then.call(x, (y) &#x3D;&gt; &#123;</span><br><span class="line">                    &#x2F;&#x2F; resolve(y);</span><br><span class="line">                    &#x2F;&#x2F; 递归调用</span><br><span class="line">                    resolvePromise(promise, y, resolve, reject);</span><br><span class="line">                &#125;, (e) &#x3D;&gt; &#123;</span><br><span class="line">                    reject(e);</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                resolve(x);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (error) &#123;</span><br><span class="line">            &#x2F;&#x2F; 如果抛出异常，执行reject</span><br><span class="line">            reject(error);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        &#x2F;&#x2F; 常量等</span><br><span class="line">        resolve(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在then方法中补充完整逻辑并增加setTimeout支持异步：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">Promise.prototype.then &#x3D; function (onFulfilled, onRejected) &#123;</span><br><span class="line"></span><br><span class="line">    let self &#x3D; this;</span><br><span class="line"></span><br><span class="line">    let promise2; &#x2F;&#x2F; 用于保存最终需要return的promise对象</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    if (this.state &#x3D;&#x3D;&#x3D; RESOLVED) &#123;</span><br><span class="line">        promise2 &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">            &#x2F;&#x2F; 异步执行</span><br><span class="line">            setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    let x &#x3D; onFulfilled(self.value);</span><br><span class="line">                    resolvePromise(promise2, x, resolve, reject);</span><br><span class="line">                &#125; catch (error) &#123;</span><br><span class="line">                    reject(error);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (this.state &#x3D;&#x3D;&#x3D; REJECTED) &#123;</span><br><span class="line">        promise2 &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">            setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    let x &#x3D; onRejected(self.value);</span><br><span class="line">                    resolvePromise(promise2, x, resolve, reject);</span><br><span class="line">                &#125; catch (error) &#123;</span><br><span class="line">                    reject(error)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (this.state &#x3D;&#x3D;&#x3D; PENDING) &#123;</span><br><span class="line">        promise2 &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">            self.onFulfilledFunc.push(() &#x3D;&gt; &#123;</span><br><span class="line">                setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        let x &#x3D; onFulfilled(self.value);</span><br><span class="line">                        resolvePromise(promise2, x, resolve, reject);</span><br><span class="line">                    &#125; catch (error) &#123;</span><br><span class="line">                        reject(error);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            self.onRejectedFunc.push(() &#x3D;&gt; &#123;</span><br><span class="line">                setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        let x &#x3D; onRejected(self.value);</span><br><span class="line">                        resolvePromise(promise2, x, resolve, reject);</span><br><span class="line">                    &#125; catch (error) &#123;</span><br><span class="line">                        reject(error);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    return promise2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>至此，我们手写的Promise就基本可以使用了。  </p>
<p>以上是对Promise相关知识的一些整理，其中浏览器的事件循环以及手写Promise也是前端面试中比较重要的考察点，如有错误，欢迎指正。</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p>[1] <a href="https://www.jianshu.com/p/84ef1b48fcce" target="_blank" rel="noopener">Promise精选面试题</a><br>[2] <a href="https://www.jianshu.com/p/7e60fc1be1b2" target="_blank" rel="noopener">理解和使用Promise.all和Promise.race</a><br>[3] <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise" target="_blank" rel="noopener">Promise API</a><br>[4] <a href="https://www.jianshu.com/p/c633a22f9e8c" target="_blank" rel="noopener">只会用？一起来手写一个合乎规范的Promise</a><br>[5] <a href="https://www.jianshu.com/p/77a4f2c9d18b" target="_blank" rel="noopener">手写Promise</a><br>[6] <a href="https://www.ituring.com.cn/article/66566" target="_blank" rel="noopener">【翻译】Promises/A+规范</a><br>[7] <a href="https://github.com/YuetTusi/promise/blob/master/promise.js" target="_blank" rel="noopener">promise by yuet</a><br>[8] [es6-design-mode by Cheemi](</p>

            
                

            
        </div>
        <div class="post-tool">
            <a class="btn-thumbs-up" href="javascript:void(0);" data-cid="52" title="95">
                <i class="fa fa-thumbs-up" aria-hidden="true"></i> 嘘寒问暖，不如打笔巨款。
            </a>
        </div>
        
        <div class="post-tags">标签：
            
            <a href="/tags/%E6%8A%80%E6%9C%AF/">技术</a>
            
        </div>
        
    </article>
    
        <p style="text-align: center">本文代表个人观点，内容仅供参考。若有不恰当之处，望不吝赐教！</p>
    
    
    

</div>

<script src="/js/busuanzi.pure.mini.js"></script>



        </div><!-- end #main-->
    </div><!-- end #body -->
    <footer class="footer">
    <div class="footer-inner" style="text-align: center">
        <p>
            <a href="/about"  title="我们~">我们~</a>&nbsp;&nbsp<em>·</em>&nbsp;&nbsp
            <!-- 自定义链接 -->
            <a href="/help" title="帮助" >帮助</a>&nbsp;&nbsp<em>·</em>&nbsp;&nbsp
            <a href="/links" title="友链">友链</a>&nbsp;&nbsp<em>·</em>&nbsp;&nbsp
            <a href="/sitemap.xml" title="地图">地图</a>
        </p>
        <p>
            本站已建立&nbsp<a href="/timeline" id="siteBuildingTime"></a>&nbsp天，<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="licence">采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议创作</a><br/>
            ©2017-<span id="cpYear"></span> 基于&nbsp<a href="http://hexo.io" target="_blank" rel="nofollow">Hexo</a>
            ，主题采用&nbsp&nbsp<a href="https://github.com/tangkunyin/hexo-theme-jsimple" target="_blank" rel="bookmark">JSimple</a>
            ，站点所有&nbsp<a href="https://juejin.im/user/5dfad50cf265da33d21e7e0d/posts" target="_blank" rel="friend">skFe</a>
            ，Hosted by <a href="https://pages.github.com/" target="_blank" rel="nofollow">GitHub Pages</a>
        </p>
    </div>
</footer>

<script src="/js/SimpleCore.js"></script>


</div>
<!-- search pop -->
<div class="popup search-popup local-search-popup">
    <div class="local-search-header clearfix">
        <span class="search-icon">
            <i class="fa fa-search"></i>
        </span>
        <span class="popup-btn-close">
            <i class="fa fa-times-circle"></i>
        </span>
        <div class="local-search-input-wrapper">
            <input id="local-search-input"
                   spellcheck="false"
                   type="text"
                   autocomplete="off"
                   placeholder="请输入查询关键词"/>
        </div>
    </div>
    <div id="local-search-result"></div>
</div>
<div class="fixed-btn">
    <a class="btn-gotop" href="javascript:"> <i class="fa fa-angle-up"></i></a>
</div>
<script>
    $(function () {
        var jsi_config = {
            buildingTime: '12/18/2019',
            current: $('.post-tags').length > 0 ? 'post' : 'archive',
            snsQRCode: '/images/sns-qrcode.png',
            donateImg: '/images/donate-qr.png',
            localSearch: { dbPath: '' },
            readMode: 'day'
        };
        
        SimpleCore.init(jsi_config);
        
    });
</script>
</body>
</html>
